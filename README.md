# 《简易记账本》-开发笔记

无任何第三方依赖，原生js实现，使用了MVC设计模式，完全采用es6编写，esm模块开发

(未打包编译成es5，因为题目要求项目不依赖任何库以及node_modules，故选择了纯原生方式)


### 启动应用
> 方式1.[全局安装http-server或其他本地web服务器]，使用命令行cd到项目web目录下，执行http-server -o -p 8080（或项目中npm run dev）
>（http-server最新版需node13以上才能运行）
>
> 方式2.或者使用一些开发工具内置服务，例如webstorm直接右键index.html选择run启动页面

### 单元测试
> 采用Karma + Mocha + Chai + Sinon + ChromeHeadless进行测试，仅测试了核心部分，点到为止！
>
> 启动：npm run test (需要全局安装karma + karma-cli，然后项目npm install)

### 1. 应用结构

```
|-- assets              //公共资源文件
|   |--components       //常用组件
|   |--constants        //存放常量配置
|   |--data             //模拟的数据源
|   |--mixins           //视图控制器等基类
|   |--models           //数据模型（含集合）
|   |--styles           //常用样式
|   |--utils            //工具类
|-- modules             //页面模块
|   |--module           //单个模块
|      |--components    //模块私有组件
|      |--views         //模块视图
|      |--index.js      //模块控制器
|-- index.css           //主体样式
|-- index.html          //主体HTML
|-- index.js            //主体js
```

### 2. 应用核心关键：MVC，OOP思想
> 在前端应用中选择原生开发（即不依赖现有的任何第三方框架例如vue，react等），那么MVC（模型，视图，控制器）同时结合OOP（面向对象）
> 的思想去设计和组织代码逻辑，依旧可以让一个复杂应用或复杂逻辑的单页工程化，无论是维护性和拓展性都是非常不错的，
> 所以只要做了设计模式的约定且严格执行，项目就豁然开朗，甚至本项目可以说没有遇到任何难点，可以非常丝滑写完，毕竟项目内容本身很简单。
> 
> 当然这个MVC理解很多，写法也千奇百怪，不过常见的2个版本：
> 
> 1.控制器C操作模型M，模型M更新视图V，业务逻辑被放置到模型中，视图和模型高度依赖，一般控制器不直接操作视图，而是操作模型
> 
> 2.控制器C操作模型M，控制器C更新视图V，业务逻辑被放置到控制器C，控制器C就是一个完完全全的调度者(严格意义上说这个是后来出现的MVP设计模式，即改良版的MVC，但本质还是MVC)，
> 这样模型M和视图V完全隔离，全权交给控制器C来控制
> 
> 我更喜欢的和采用的是第二种方式（同时也结合了一些数据驱动视图的模式，参考下面的代码结构介绍），
> 这种模式的好处是视图V和模型M完全隔离更加利于单元测试，同时模型M可以专心处理数据，更好的作为数据处理工厂，

```
   //下面开始说明如何结合本项目来融入MVC和OOP思想，首先是M（模型）部分
   //1.首先从本地或云端取得一条数据[我们称之为：原始数据]
   var data = { 
      "type": 0,
      "time": 1561910400000,
      "category": "0fnhbcle6hg",
      "amount": 1500
   }
   //对于这种数据可能我们第一眼看到的本能是反应是看不懂这是啥或今天清楚了，一个月后又忘记了
   //而引用模型的好处就是把[原始数据]封装为一个模型对象和模型集合，后续就可以直接读写以及管理这个模型对象和模型集合即可操作原始数据，以及和服务器数据交互
   
   //1.那么我们通过OOP模式（面向对象开发）先定义一个MDObject类和MCObject的类，里面可以内置很多公共对象操作方法;
   //2.在定义一个MDBill和MCBill来继承MDObject和MCObject;
   //***模型对象的例子
   var bill = new MDBill();
   bill.fetch();     //云端获取
   bill.save();      //云端提交
   bill.detele();    //云端删除
   //对模型写属性
   bill.set('amount', 1000);
   //对模型读操作
   bill.get('type');
   //其优点时可以内置各种数据处理方法，让我们可以在控制器中专心写业务逻辑代码
   bill.getTime('YYYY-MM-DD');
   //还可以进行丰富的数据校验（参考项目中表单提交部分）
   bill.validate('xxx');
   
   //***模型集合的例子
   var billCollection = new MCBill();
   billCollection.fetch(); //云端获取
   //同样也可以自己定义各种数据处理方法
   billCollection.getModels();
   billCollection.sort();
   billCollection.search();
   billCollection.push();
   billCollection.insert();
   
   //这样就脱离了枯燥的原始数据处理，通过封装，继承，多态让数据管理变的更加得心应手并且抽离成模块全局共享
```

### 3. 应用核心关键：模块化开发
> 在esModule，amd，cmd, commonJs等模范出来之前，管理代码是真的灾难，大量的function包裹，依赖处理更是严重混乱，维护起来也非常痛苦。
> 为了让项目工程化，具备较高的维护性和可拓展性，一个页面通常需要拆分成多个模块，和各种组件（组件又分为公共组件和私有组件）和数据模块，怎么拆，什么时候拆，我的经验如下：
> 
> 1.怎么定义为模块：简单来说就是界面上直接呈现的且能完整拆分的视图区域（比如banner模块，列表模块1，列表模块2，一般按功能区划分）
>
> 2.怎么定义为公用组件：我理解的就是说复用程度非常高的零部件（可能是公共基础组件，也可能是公共业务组件），文件则建议放在公共资源目录
>
> 3.怎么定义为私有组件：我理解的就是模块与模块之间一定要低耦合，但是有时候一个模块感觉还不够细，
> 继续划分成模块后耦合又太强，这个时候就可以引入私有组件的概念了，模块与组件之间本身就具备高交互性，
> 通常这种都是弹窗之类的（也不绝对，不一定都是弹窗，也可能就是模块中的一个局部视图，这个还要看情况），
> 因为弹窗有个特定就是你根本不知道它会在什么时候在什么地方弹出来，既有可能有2个地方要求弹出来，那么就形成了一定的复用性，
> 就算只有一个地方调用不复用，也特别适合拆分成私有组件的形式让单个模块业务或逻辑继续解耦，文件则建议放在所在的模块文件夹内
>
> 4.怎么定义为数据模块：这个就是前面说的数据模型，这个创建出来就是单独的模块，不需要像页面那样还要主观的去思考怎么划分页面的模块和组件
> 
> **当模块和组件拆分好后的一个关系就是，页面 --填充--> 模块 --调用（或渲染）--> 组件（私有和共有）


### 4. 主模块核心代码结构(注释已说明结构用意)
（其他模块和私有组件都共用该结构，因为组件本质还是模块，只是把模块拆分的更细一点）

```
//模块视图(继承基类，提供公共视图方法)
class View extends ViewBase {
    //提供视图所需外部数据源
    sources = {}
    //提供视图所需的事件方法
    events = {}
    //构造时注入挂载节点，控制器实例和事件传导
    constructor(controller, el)
    //一系列创建视图并渲染的方法
    render...() {}
}

//模块控制器(继承基类，提供公共控制器方法)
class Controller extends ControllerBase  {
   //初始化时启动首次的数据加载，事件监听等（利用前面提到的对象模型集合来加载数据和集合数据监听）
   constructor() {}
   mouted() {
     //在控制器中注入视图实例
     this.$view = new View(this, '#app');
     //给视图传递数据源
     this.$view.onSources(() => {
       return {
         catePickerData: xxx,
       }
     });
     //绑定视图中的事件
     this.$view.onEvents({
       onSearchData: this.onSearchData
       onSortData: this.onSortData
       onCreateListItem: this.onCreateListItem
     });
   }
   //********************内置方法【各类方法提供区域】
   //********************
   //1.进行数据获取（比如从网络获取等）
   fetchListData() {}
   //2.对原始数据进行一些附加的临时计算，并以_开头的变量命名
   listDataHandler() {}
   
   
   //********************事件操作【各类事件操作区域，以on开头命名便于易读性】
   //********************
   //1.创建核心list数据监听（以数据作为驱动，只专心维护list数据，例如对数据的增删改查时完全不用关心视图操作）
   //2.list数据收到变化通知后，则统一在这一个地方进行视图更新
   onListenListData(action, data) {}
   //3.一些用户点击事件，如搜索，重排序，创建条目等
   onSearchData() {}
   onSortData() {}
   onCreateListItem() {
    （通过下面方式弹出私有组件或公共组件，以回调的形式进行交互处理更加集中和清晰）
     this.billFormEditor.show({
       onCreate: (data) => {}
     })
   }
}
```
